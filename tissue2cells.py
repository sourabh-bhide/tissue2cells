# The code was generated by Sourabh Bhide (sourabh.j.bhide)
#!/usr/bin/env python
# coding: utf-8

# In[4]:


import numpy as np
import pandas as pd
import scipy
from scipy import ndimage
import scipy.misc
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from PIL import Image
from scipy.signal import find_peaks
import skimage.feature
from scipy import misc, ndimage, spatial
from skimage import feature
from skimage.filters import threshold_otsu
import imageio
from skimage import io
from PIL import Image as pilimage
from sklearn.metrics import pairwise_distances
from sklearn import cluster
from sklearn.metrics import silhouette_samples, silhouette_score
from sklearn.metrics.pairwise import euclidean_distances
np.set_printoptions(threshold=np.inf)
from skimage.segmentation import watershed
import math 
import os
import os.path
from sklearn.cluster import OPTICS, cluster_optics_dbscan
import matplotlib.gridspec as gridspec
from skimage import filters
from skimage import exposure
from skimage import util 
from skimage import measure
import matplotlib.cm as cm

###########

def skewness_cells(image,mask):
    from scipy.stats import skew
    indices = np.where(image)
    coordinates = zip(indices[0], indices[1])
    y_coord = np.asarray(indices[0])
    return skew(y_coord)

def DV_Assymetry(box,roi):
    a,b = ndimage.measurements.center_of_mass(box)
    D=0
    V=0
    DV_ass=0
    thresh = skimage.filters.threshold_otsu(roi)
    binary = roi > thresh*0.1
    for x,y in np.column_stack(np.where(binary)):#(myo_binary_cell > 254)
        if y < int(a) :V = V+1
        else: D = D+1

    if (D==0 and V==0): DV_ass = 0
    else : DV_ass = V/(D+V)
            
    return DV_ass
           
    
def measure_cell_properties(mask,myosin,number_of_cells,t):
    centroid = []
    offset = []
    area_cells =[]
    sum_myosin_cells = []
    concerntration=[]
    skewness_cell = []
    DV_asymmetry= []
    eccentricity = []
    
    for i in range (number_of_cells):
        
        cell_mask = mask == i
        myo_cell = myosin * cell_mask
        labels, number_of_objects = ndimage.label(cell_mask)
        
        slice_x, slice_y = ndimage.find_objects(labels==1)[0]
        box = cell_mask[slice_x, slice_y]
        roi = myo_cell[slice_x, slice_y]
        
        props = skimage.measure.regionprops(box.astype(int),roi)
        
        weighted_cent = props[0].weighted_local_centroid
        weighted_cent = np.nan_to_num(weighted_cent)
        cent = props[0].centroid
        area = props[0].area
        cent = np.nan_to_num(cent)
        ecc = props[0].eccentricity
        ecc = np.nan_to_num(ecc)
        
        
        off_center = spatial.distance.euclidean(cent, weighted_cent)
        off_center = np.nan_to_num(off_center)
        
        #area = ndimage.measurements.sum(cell,labels==1)
        sum_myosin = ndimage.measurements.sum(myo_cell)
        conc = sum_myosin/area

        DV_assy = DV_Assymetry(box,roi)
        DV_asymmetry= np.append(DV_asymmetry,DV_assy)
      
        
        skewness = skewness_cells(roi,box)
        skewness_cell=np.append(skewness_cell,skewness)
        
        area_cells = np.append(area_cells,area)
        centroid = np.append(centroid,cent,axis=0)
        offset = np.append(offset,off_center)
        sum_myosin_cells = np.append(sum_myosin_cells,sum_myosin)
        concerntration = np.append(concerntration,conc)
        eccentricity = np.append(eccentricity,ecc)
    
    B = np.reshape(centroid, (-1, 2))
    C = pd.DataFrame(data=B, index=None, columns=["center_y_cells", "center_x_cells"])
    D = np.reshape(offset, (-1, 1))
    E = pd.DataFrame(data=D, index=None, columns=["offset"])
    F = np.reshape(area_cells, (-1, 1))
    G = pd.DataFrame(data=F, index=None, columns=["area_cells"])
    H = np.reshape(sum_myosin_cells, (-1, 1))
    I = pd.DataFrame(data=H, index=None, columns=["sum_myosin_cells"])

    J = np.reshape(eccentricity, (-1, 1))
    K = pd.DataFrame(data=J, index=None, columns=["eccentricity"])

    N = np.reshape(concerntration, (-1, 1))
    O = pd.DataFrame(data=N, index=None, columns=["concerntration_cells"])
    
    P= np.reshape(DV_asymmetry, (-1, 1))
    Q= pd.DataFrame(data=P, index=None, columns=["DV_asymmetry"])
    
    R= np.reshape(skewness_cell, (-1, 1))
    S= pd.DataFrame(data=R, index=None, columns=["skewness_cell"])

    df1 = pd.concat([C,E,I,K,O,Q,S],axis=1, sort=True)
    df = pd.concat([G,df1],axis=1, sort=True)
    return df

def measure_props(start,stop,master_data):
    measured_data = pd.DataFrame()
    df = pd.DataFrame()
    for t in range (start,stop):
        cell_identity = f['segmentation'][:] # check the correct dataset name in the hdf5 file
        myosin = f['myosin'][:] #
        
        a = os.path.join(basepath, cell_identity)
        b = os.path.join(basepath, myosin)
                
        mask = np.array(Image.open(str(a)))
        myosin = np.array(Image.open(str(b)))
        
        number_of_cells = master_data.frame_nb[master_data.frame_nb == t].count()
        
        df = tc.measure_cell_properties (mask,myosin,number_of_cells,myo_seg)
        measured_data= measured_data.append(df)
        print("Frame number "+str(t)+" is imported")
    measured_data.to_csv('measured_data.csv', sep=';', decimal=',')
    print('DONE')

def get_concat_h_multi_resize(im_list, resample=Image.BICUBIC):
    min_height = min(im.height for im in im_list)
    im_list_resize = [im.resize((int(im.width * min_height / im.height), min_height),resample=resample)
                      for im in im_list]
    total_width = sum(im.width for im in im_list_resize)
    dst = Image.new('RGB', (total_width, min_height))
    pos_x = 0
    for im in im_list_resize:
        dst.paste(im, (pos_x, 0))
        pos_x += im.width
    return dst

def get_concat_v_multi_resize(im_list, resample=Image.BICUBIC):
    min_width = min(im.width for im in im_list)
    im_list_resize = [im.resize((min_width, int(im.height * min_width / im.width)),resample=resample)
                      for im in im_list]
    total_height = sum(im.height for im in im_list_resize)
    dst = Image.new('RGB', (min_width, total_height))
    pos_y = 0
    for im in im_list_resize:
        dst.paste(im, (0, pos_y))
        pos_y += im.height
    return dst

def get_concat_h_blank(im1, im2, color=(0, 0, 0)):
    dst = Image.new('RGB', (im1.width + im2.width, max(im1.height, im2.height)), color)
    dst.paste(im1, (0, 0))
    dst.paste(im2, (im1.width, 0))
    return dst

def get_concat_h_multi_blank(im_list):
    _im = im_list.pop(0)
    for im in im_list:
        _im = get_concat_h_blank(_im, im)
    return _im

def Mon(im_list):
    _im = im_list.pop(0)
    for im in im_list:
        _im = get_concat_h_blank(_im, im)
    return _im
    
def make_montage_cells(name,track_id_list,signal,start,stop):
    for track_id in track_id_list :
            images = []
            for t in range(start,stop):
                filename = f'Cells_tracked_{name}/Cell_{signal}_{track_id}_frame_{t}.png'##########actin or myosin
                if os.path.exists(filename):
                    img = Image.open(str(filename))
                    images.append(img)
                    
            get_concat_h_multi_blank(images).save(f'Cells_tracked_{name}/Montage_Cell_{signal}_{track_id}.png')
